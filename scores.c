#include "scores.h"
#include <stdlib.h>
#include <stddef.h>
#include <math.h>
#include "./io/io.h"
#include "./io/bits.h"


#ifndef SCORE_BUFFER_CAPACITY
#define SCORE_BUFFER_CAPACITY 50  // In characters. The buffer does not grow.
#endif
#ifndef N_SCORES
#define N_SCORES 8
#endif
#ifndef LENGTH_SCORE_EPSILON
#define LENGTH_SCORE_EPSILON 0.1
#endif
#ifndef INITIAL_SCORE_STACK_CAPACITY
#define INITIAL_SCORE_STACK_CAPACITY 128  // In float numbers
#endif


/**
 * For $scoreSelect$. Values must be set elsewhere.
 */
unsigned char SELECTED_SCORE;
double SELECTED_SCORE_THRESHOLD;


inline void scoreInitialize(score_state_t *scoreState) {
	scoreState->scores=(double *)malloc(N_SCORES*sizeof(double));
	scoreState->score_stack_capacity=INITIAL_SCORE_STACK_CAPACITY;
	scoreState->score_stack=(double *)malloc(scoreState->score_stack_capacity*sizeof(double));
	scoreState->scoreBuffer=(char *)malloc(SCORE_BUFFER_CAPACITY*sizeof(char));
}


inline void scoreFinalize(score_state_t *scoreState) {
	free(scoreState->scores);
	free(scoreState->score_stack);
	free(scoreState->scoreBuffer);
}


/**
 * Length score used in \cite{crochemore2016linear}.     
 */
static inline double lengthScore1(unsigned int length) {
	return 1.0/(length*length);
}


/**
 * Length score used in \cite{smola2003fast}.     
 */
static inline double lengthScore2(unsigned int length) {
	return pow(LENGTH_SCORE_EPSILON,length);
}


/**
 * Stores in  $scoreState->scores$ the following scores for a MAW $W=aVb$:
 * 
 * 0. the expected frequency of $W$ if the text is generated by an IID source;
 * 1. the probability of observing $W$ according to the model in (1);
 * 2. a z-score based on (1) (see \cite{apostolico2000efficient,apostolico2003monotony});
 *
 * 3. the expected frequency of $W$, if the text is generated by a Markov chain of order 
 * at most $|W|-2$ (see \cite{almirantis2016optimal,brendel1986linguistics});
 * 4. an estimate of the probability of observing $W$ according to the model in (4)
 * (see \cite{qi2004whole,apostolico2008fast});
 * 5. a z-score based on (1);
 *
 * 6. the length-based score defined by $lengthScore1$;
 * 7. the length-based score defined by $lengthScore2$.
 */
inline void scoreCallback(unsigned int leftCharID, unsigned int rightCharID, unsigned int leftFreq, unsigned int rightFreq, unsigned int textLength, SLT_params_t *SLT_params, score_state_t *scoreState) {
	const unsigned int STRING_LENGTH = SLT_params->string_depth+2;
	double tmp;
	double expectedFrequencyIID, probabilityIID, zScoreIID;
	double expectedFrequencyMarkov, probabilityMarkov, zScoreMarkov;
	double ls1, ls2;
	
	// IID
	probabilityIID=pow(M_E,LOG_DNA_ALPHABET_PROBABILITIES[leftCharID]+scoreState->score_stack[SLT_params->string_depth-1]+LOG_DNA_ALPHABET_PROBABILITIES[rightCharID]);
	expectedFrequencyIID=probabilityIID*(textLength-STRING_LENGTH+1);
	zScoreIID=-expectedFrequencyIID/sqrt(expectedFrequencyIID*(1-probabilityIID));
	
	// Markov
	expectedFrequencyMarkov=((double)(leftFreq*rightFreq))/SLT_params->interval_size;
	tmp=textLength-STRING_LENGTH+2;
	tmp=(tmp+1)/(tmp*tmp);
	probabilityMarkov=expectedFrequencyMarkov*tmp;
	zScoreMarkov=-expectedFrequencyMarkov/fmax(sqrt(expectedFrequencyMarkov),1.0);
	
	// Length
	ls1=lengthScore1(STRING_LENGTH);
	ls2=lengthScore2(STRING_LENGTH);
	
	// Output
	scoreState->scores[0]=expectedFrequencyIID;
	scoreState->scores[1]=probabilityIID;
	scoreState->scores[2]=zScoreIID;
	scoreState->scores[3]=expectedFrequencyMarkov;
	scoreState->scores[4]=probabilityMarkov;
	scoreState->scores[5]=zScoreMarkov;
	scoreState->scores[6]=ls1;
	scoreState->scores[7]=ls2;
}


/**
 * Updates just the log of the product of character probabilities of the string in the 
 * stack.
 */
inline void scorePush(unsigned char charID, unsigned int stringDepth, score_state_t *scoreState) {
	const unsigned int CAPACITY = scoreState->score_stack_capacity;
	double probabilityIID;
	
	if (stringDepth>CAPACITY) {
		scoreState->score_stack_capacity+=MY_CEIL(scoreState->score_stack_capacity*ALLOC_GROWTH_NUM,ALLOC_GROWTH_DENOM);
		scoreState->score_stack=(double *)realloc(scoreState->score_stack,scoreState->score_stack_capacity*sizeof(double));
	}
	probabilityIID=LOG_DNA_ALPHABET_PROBABILITIES[charID];
	if (stringDepth>1) probabilityIID+=scoreState->score_stack[stringDepth-2];
	scoreState->score_stack[stringDepth-1]=probabilityIID;
}


/**
 * Scores are separated by $OUTPUT_SEPARATOR_1$.
 * The procedure assumes $scoreState->scoreBuffer$ to be large enough to contain a score.
 */
inline void scorePrint(score_state_t *scoreState, buffered_file_writer_t *file) {
	unsigned char i, j, nCharacters;
	
	for (i=0; i<N_SCORES; i++) {
		nCharacters=sprintf(scoreState->scoreBuffer,"%g%c",scoreState->scores[i],OUTPUT_SEPARATOR_1);
		for (j=0; j<nCharacters; j++) writeChar(scoreState->scoreBuffer[j],file);
	}
}


/**
 * Returns 0 iff the absolute value of $scores[SELECTED_SCORE]$ is at least 
 * $SELECTED_SCORE_THRESHOLD$.
 */
inline char scoreSelect(score_state_t *scoreState) {
	return fabs(scoreState->scores[SELECTED_SCORE])>=SELECTED_SCORE_THRESHOLD?1:0;
}